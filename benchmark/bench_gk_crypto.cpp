#include <cstdint>
#include <iostream>
#include <string>

#include <benchmark/benchmark.h>

#include "gk_crypto.h"

static void BM_TimeLockPuzzle_Squaring(benchmark::State &state) {
  int ret;
  for (auto _ : state) {
    // 1000 times squaring operations
    ret = gk_benchmark_puzzle(1000);
    if (ret != 0) {
      state.SkipWithError("Failed to benchmark the puzzle!");
      break;
    }
  }
}
BENCHMARK(BM_TimeLockPuzzle_Squaring);

static void BM_TimeLockPuzzle_Generating(benchmark::State &state) {
  int ret;
  time_lock_puzzle_ex puzzle_ex = {0x00};

  gk_crypto_init();

  for (auto _ : state) {
    ret = gk_generate_puzzle(state.range(0), 56392, &puzzle_ex);
    if (ret != 0) {
      state.SkipWithError("Failed to generate the puzzle!");
      break;
    }
  }

  gk_crypto_exit();
}
BENCHMARK(BM_TimeLockPuzzle_Generating)->DenseRange(100, 1000, 100);

static void BM_TimeLockPuzzle_Solving(benchmark::State &state) {
  int err;
  uint64_t ans;
  time_lock_puzzle_ex puzzle_ex = {0x00};

  gk_crypto_init();

  err = gk_generate_puzzle(state.range(0), 56392, &puzzle_ex);

  for (auto _ : state) {
    ans = gk_solve_puzzle(&puzzle_ex.puzzle, &err);
    if (err != 0) {
      state.SkipWithError("Failed to solve the puzzle!");
      break;
    }
    if (ans != puzzle_ex.solution) {
      state.SkipWithError("Wrong puzzle solution!");
      break;
    }
  }

  gk_crypto_exit();
}
BENCHMARK(BM_TimeLockPuzzle_Solving)->DenseRange(100, 1000, 100);

/*
 * `rsa_digest` is the SHA256 hash of `rsa_msg`
 */
static unsigned char rsa_digest[] =
    "\x3e\xc8\xa1\x26\x20\x54\x44\x52\x48\x0d\xe5\x66\xf3\xb3\xf5\x04"
    "\xbe\x10\xa8\x48\x94\x22\x2d\xdd\xba\x7a\xb4\x76\x8d\x79\x98\x89";
static unsigned int rsa_digest_size = 32;
/*
 * `rsa_sig` is generated by kernel cipher `pkcs1pad(rsa,sha256)`
 */
static unsigned char rsa_sig[] =
    "\x5e\x41\x1d\x0f\x3d\x4e\x6d\x43\xd4\xd7\x0b\x66\x2f\x22\xaf\x17"
    "\x10\x3d\x6d\x24\x45\xd7\xfa\x94\x9b\x53\x2d\x69\x9d\x2b\x38\x7a"
    "\x07\xf2\x1a\x64\x67\x27\xfe\x46\xc7\xf8\x06\xa5\xf6\x2b\x39\xfe"
    "\xd1\xb3\xfe\x83\xa7\x75\xeb\xc1\x94\xfd\x37\xbf\x8f\x1b\x1f\x32"
    "\x06\x91\x41\x8a\x96\x51\x48\x1a\x77\x1b\xb3\x3e\x25\x5c\xd5\x9b"
    "\x93\x6f\x9f\x04\xe9\x0c\x03\x7b\xd7\x8e\x63\xf1\xff\x02\xa5\xf6"
    "\xa4\x29\x24\x3d\xf9\x43\x53\xf8\xb8\x11\x8c\x84\xd0\x02\xd5\x4e"
    "\xa8\x83\x55\x3c\x40\xb4\x2c\x4e\x39\xfb\x7c\x0f\x02\x1a\xba\xce"
    "\x43\xd5\x0d\xfb\xd0\x98\xc4\x28\x84\x82\x0a\xb6\xf5\xe2\xc4\x45"
    "\x28\x33\x29\xb6\x27\x9b\x86\x63\x47\x20\xa9\xc1\x67\x8c\x3b\x5c"
    "\x6b\xeb\xd8\x5b\x05\xa2\x43\x0d\xfc\xbc\xfc\x02\x4f\xf5\xcf\xcc"
    "\xfc\x9d\xea\x3a\x6b\x05\xf8\xad\xd1\x22\x9a\xa1\xc9\xc3\xc4\x13"
    "\xf4\x89\x46\x68\x3e\xc7\x52\x54\xdb\x31\x53\xe6\xd7\xec\x67\x6c"
    "\xd3\x9f\x68\x28\x62\x07\x24\x08\x9a\xc5\xd1\x78\xf6\xc3\xe2\xff"
    "\x4c\x8d\x3d\xf6\x2d\xed\xde\xd8\x4f\x7b\xa9\x60\x64\xe0\x65\x5f"
    "\x36\xc5\xfb\x83\x7f\x8a\x16\x10\x1f\xf9\x64\xe0\x1d\x47\xd1\x9c";
static unsigned int rsa_sig_size = 256;
static void BM_RSA2048_Verification(benchmark::State &state) {
  int ret;
  for (auto _ : state) {
    ret = gk_rsa2048_verify(rsa_digest, rsa_digest_size, rsa_sig, rsa_sig_size);
    if (ret != 0) { state.SkipWithError("Verification failed!"); }
  }
}
BENCHMARK(BM_RSA2048_Verification);

BENCHMARK_MAIN();
