#include "gtest/gtest.h"

#include "gk_crypto.h"

TEST(GkCryptoTest, TestTimeLockPuzzle) {
  int ret;
  uint64_t ans;
  time_lock_puzzle_ex puzzle_ex = {0x00};

  std::cout << sizeof(puzzle_ex.puzzle) << std::endl;

  gk_crypto_init();

  ret = gk_generate_puzzle(500, 100, &puzzle_ex);
  EXPECT_EQ(ret, 0);

  ans = gk_solve_puzzle(&puzzle_ex.puzzle, &ret);
  EXPECT_EQ(ret, 0);

  ASSERT_EQ(ans, puzzle_ex.solution);

  gk_crypto_exit();
}

TEST(GkCryptoTest, TestTimeLockPuzzleGeneration) {
  int ret;
  time_lock_puzzle_ex puzzle_ex = {0x00};

  gk_crypto_init();

  for (uint32_t T = 500; T <= 1000; T += 500) {
    ret = gk_generate_puzzle(T, 2000, &puzzle_ex);
    EXPECT_EQ(ret, 0);
  }

  gk_crypto_exit();
}

/* The following puzzle is generated by the kernel module */
static uint64_t solution = 12996884855796757992ULL;
static uint8_t puzzle_payload[] =
    "\xbf\x72\xa6\x0c\x88\xad\x7a\xcf\x11\x57\x0e\xee\x29\x8e\x2b\x60"
    "\xf8\x54\x04\xa9\xad\xe1\xb9\xf8\xe9\x6e\x19\xf6\x9f\x01\x7f\x5a"
    "\x13\x6b\x8d\xa0\xc0\xb8\x34\xd8\x80\x22\x63\xcd\x0a\xe9\x55\x78"
    "\x76\x95\xa5\xf3\x95\xeb\xdd\x66\xe9\x6b\xac\x2b\x07\x57\xd7\x59"
    "\x0a\x00\x00\x00\x00\x00\x00\x00\x87\x1d\x8c\xfa\x53\x85\xcb\x25"
    "\x12\xfa\x6a\xf8\x89\xab\x74\x01\x19\x3f\x15\x6b\x2f\x30\x00\x78"
    "\x2e\x6e\x43\x8c\x6b\x8e\x8e\x73\xcf\xe5\x7a\xbb\x33\x25\x00\x5a"
    "\xb4\x55\x9c\x72\xe4\x05\x8c\x6d\x82\xf2\xfe\x02\xf0\x70\xf6\xc6"
    "\x77\x79\x6d\xe1\x83\x8b\x8f\x0e\x6b\x6d\x88\x24\x08\x49\x5a\xb6"
    "\x82\x50\xdb\x22\xc3\x18\xd7\x76";

TEST(GkCryptoTest, TestTimeLockPuzzleSolving) {
  int ret;
  uint64_t ans;
  time_lock_puzzle puzzle = {0x00};
  memcpy(&puzzle, puzzle_payload, sizeof(time_lock_puzzle));

  gk_crypto_init();

  ans = gk_solve_puzzle(&puzzle, &ret);
  EXPECT_EQ(ret, 0);

  ASSERT_EQ(ans, solution);

  gk_crypto_exit();
}

/*
 * `rsa_digest` is the SHA256 hash of `rsa_msg`
 */
unsigned char rsa_digest[] =
    "\x3e\xc8\xa1\x26\x20\x54\x44\x52\x48\x0d\xe5\x66\xf3\xb3\xf5\x04"
    "\xbe\x10\xa8\x48\x94\x22\x2d\xdd\xba\x7a\xb4\x76\x8d\x79\x98\x89";
unsigned int rsa_digest_size = 32;
/*
 * `rsa_sig` is generated by kernel cipher `pkcs1pad(rsa,sha256)`
 */
unsigned char rsa_sig[] =
    "\x5e\x41\x1d\x0f\x3d\x4e\x6d\x43\xd4\xd7\x0b\x66\x2f\x22\xaf\x17"
    "\x10\x3d\x6d\x24\x45\xd7\xfa\x94\x9b\x53\x2d\x69\x9d\x2b\x38\x7a"
    "\x07\xf2\x1a\x64\x67\x27\xfe\x46\xc7\xf8\x06\xa5\xf6\x2b\x39\xfe"
    "\xd1\xb3\xfe\x83\xa7\x75\xeb\xc1\x94\xfd\x37\xbf\x8f\x1b\x1f\x32"
    "\x06\x91\x41\x8a\x96\x51\x48\x1a\x77\x1b\xb3\x3e\x25\x5c\xd5\x9b"
    "\x93\x6f\x9f\x04\xe9\x0c\x03\x7b\xd7\x8e\x63\xf1\xff\x02\xa5\xf6"
    "\xa4\x29\x24\x3d\xf9\x43\x53\xf8\xb8\x11\x8c\x84\xd0\x02\xd5\x4e"
    "\xa8\x83\x55\x3c\x40\xb4\x2c\x4e\x39\xfb\x7c\x0f\x02\x1a\xba\xce"
    "\x43\xd5\x0d\xfb\xd0\x98\xc4\x28\x84\x82\x0a\xb6\xf5\xe2\xc4\x45"
    "\x28\x33\x29\xb6\x27\x9b\x86\x63\x47\x20\xa9\xc1\x67\x8c\x3b\x5c"
    "\x6b\xeb\xd8\x5b\x05\xa2\x43\x0d\xfc\xbc\xfc\x02\x4f\xf5\xcf\xcc"
    "\xfc\x9d\xea\x3a\x6b\x05\xf8\xad\xd1\x22\x9a\xa1\xc9\xc3\xc4\x13"
    "\xf4\x89\x46\x68\x3e\xc7\x52\x54\xdb\x31\x53\xe6\xd7\xec\x67\x6c"
    "\xd3\x9f\x68\x28\x62\x07\x24\x08\x9a\xc5\xd1\x78\xf6\xc3\xe2\xff"
    "\x4c\x8d\x3d\xf6\x2d\xed\xde\xd8\x4f\x7b\xa9\x60\x64\xe0\x65\x5f"
    "\x36\xc5\xfb\x83\x7f\x8a\x16\x10\x1f\xf9\x64\xe0\x1d\x47\xd1\x9c";
unsigned int rsa_sig_size = 256;

TEST(GkCryptoTest, TestProofVerification) {
//  gk_crypto_init();
#ifdef GK_AUTH_RSA
  int ret =
      gk_rsa2048_verify(rsa_digest, rsa_digest_size, rsa_sig, rsa_sig_size);
  ASSERT_EQ(ret, 0);
#endif /* GK_AUTH_RSA */
  //  gk_crypto_exit();
}
