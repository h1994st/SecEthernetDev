#include <cstdint>

#include "gtest/gtest.h"

#include <wolfssl/options.h>
#include <wolfssl/wolfcrypt/settings.h>

#include <wolfssl/openssl/bio.h>
#include <wolfssl/wolfcrypt/hash.h>
#include <wolfssl/wolfcrypt/rsa.h>
#include <wolfssl/wolfcrypt/signature.h>

#include "wolfssl_ext.h"

TEST(WolfSSLTest, TestKeyLoading) {
  auto bio = wolfSSL_BIO_new_file("data/privkey.pem", "rb");
  EXPECT_NE(bio, nullptr);
  auto private_key =
      wolfSSL_PEM_read_bio_PrivateKey(bio, nullptr, nullptr, nullptr);
  EXPECT_NE(private_key, nullptr);
  wolfSSL_EVP_PKEY_free(private_key);
  wolfSSL_BIO_free(bio);

  bio = wolfSSL_BIO_new_file("data/pubkey.pem", "rb");
  EXPECT_NE(bio, nullptr);
  auto public_key = wolfSSL_PEM_read_bio_PUBKEY(bio, nullptr, nullptr, nullptr);
  EXPECT_NE(public_key, nullptr);
  wolfSSL_EVP_PKEY_free(public_key);
  wolfSSL_BIO_free(bio);
}

TEST(WolfSSLTest, TestBNModExp) {
  int ret;
  BIGNUM *p;
  BIGNUM *q;
  BIGNUM *bn_two;
  BIGNUM *phi_n;
  BIGNUM *tmp1;
  BIGNUM *tmp2;

  p = BN_new();
  q = BN_new();
  bn_two = BN_new();
  phi_n = BN_new();
  tmp1 = BN_new();
  tmp2 = BN_new();
  ASSERT_NE(p, nullptr);
  ASSERT_NE(q, nullptr);
  ASSERT_NE(bn_two, nullptr);
  ASSERT_NE(phi_n, nullptr);
  ASSERT_NE(tmp1, nullptr);
  ASSERT_NE(tmp2, nullptr);

  BN_init(p);
  BN_init(q);
  BN_init(bn_two);
  BN_init(phi_n);
  BN_init(tmp1);
  BN_init(tmp2);

  BN_set_word(bn_two, 2);

  // Generate two random prime numbers
  //  ret = BN_generate_prime_ex(p, 512, 0, nullptr, nullptr, nullptr);
  //  ASSERT_EQ(ret, WOLFSSL_SUCCESS);
  //
  //  ret = BN_generate_prime_ex(q, 512, 0, nullptr, nullptr, nullptr);
  //  ASSERT_EQ(ret, WOLFSSL_SUCCESS);
  // NOTE: for now, just use hard-coded prime numbers
  BN_set_word(p, 59833);
  BN_set_word(q, 62549);

  // phi_n = (p - 1) * (q - 1)
  // tmp1 = p
  BN_copy(tmp1, p);
  ret = BN_sub_word(tmp1, 1);
  ASSERT_EQ(ret, WOLFSSL_SUCCESS);
  // tmp2 = q
  BN_copy(tmp2, q);
  ret = BN_sub_word(tmp2, 1);
  ASSERT_EQ(ret, WOLFSSL_SUCCESS);
  // phi_n = tmp1 * tmp2
  ret = BN_mul(phi_n, tmp1, tmp2, nullptr);
  ASSERT_EQ(ret, WOLFSSL_SUCCESS);

  // tmp2 = 2000
  BN_set_word(tmp2, 2000);
  // tmp1 = (2 ^ tmp2) mod phi_n
  ret = BN_mod_exp(tmp1, bn_two, tmp2, phi_n, nullptr);
  ASSERT_EQ(ret, WOLFSSL_SUCCESS);

  BN_clear_free(p);
  BN_clear_free(q);
  BN_clear_free(bn_two);
  BN_clear_free(phi_n);
  BN_clear_free(tmp1);
  BN_clear_free(tmp2);
}

TEST(WolfSSLTest, TestBNModSub) {
  int ret;
  BIGNUM *a;
  BIGNUM *b;
  BIGNUM *r1;
  BIGNUM *m;

  a = BN_new();
  b = BN_new();
  r1 = BN_new();
  m = BN_new();
  ASSERT_NE(a, nullptr);
  ASSERT_NE(b, nullptr);
  ASSERT_NE(r1, nullptr);
  ASSERT_NE(m, nullptr);

  BN_init(a);
  BN_init(b);
  BN_init(r1);
  BN_init(m);

  // a > b
  BN_set_word(a, 5);
  BN_set_word(b, 3);
  BN_set_word(m, 10);
  ret = BN_mod_sub(r1, a, b, m, nullptr);
  ASSERT_EQ(ret, WOLFSSL_SUCCESS);

  // a < b
  BN_set_word(a, 1);
  BN_set_word(b, 7);
  BN_set_word(m, 10);
  ret = BN_mod_sub(r1, a, b, m, nullptr);

  BN_clear_free(a);
  BN_clear_free(b);
  BN_clear_free(r1);
  BN_clear_free(m);
}

const unsigned char rsa_key[] =
    "\x30\x82\x04\xA3\x02\x01\x00\x02\x82\x01\x01\x00\x9F\x60\xE7\xB8"
    "\x2F\x85\x21\x99\x4B\x6F\x9C\x4F\xBA\x25\x54\xD3\xBE\xD5\x06\x2D"
    "\xC3\xD7\xD8\x05\x05\x27\xD5\xF7\xBC\x37\x6C\x92\xCA\x08\xAA\x5B"
    "\x5D\xFF\x23\x29\x17\x83\x92\x56\x6A\x7A\x74\x20\x2D\x2C\xB0\xF1"
    "\x77\x1D\x6A\x17\x85\x73\xF3\xDF\xE6\x21\x4D\x9F\xE0\x86\xEA\x7D"
    "\x5D\x29\x6E\xF6\xA3\x19\xC8\x60\xD7\x9F\xFD\x25\xD4\x05\xAC\x22"
    "\xB2\xBA\xE6\x68\xFC\x59\x34\xC2\xF4\x8D\xEA\x66\x27\x8E\x4D\x3B"
    "\x33\x58\xD1\xD5\x99\x90\x13\xAF\xC1\xC6\x22\xA7\x33\xB3\x05\xB9"
    "\x3E\xA0\x67\x73\xAA\xEC\x75\xD9\x2D\x27\x46\xF5\x5F\x2D\xF2\x45"
    "\xF8\xF4\xE0\x1C\x43\x3E\x57\xDD\x1B\xAB\x13\xB7\x42\xCD\x5F\x57"
    "\x7B\xA5\x5D\x2B\x71\x3D\xC6\xF8\xDE\xD9\x1B\xFE\xA7\x39\x9C\xAF"
    "\xFC\xCE\x4C\x04\x30\xC1\x22\xDA\xB3\xC4\x17\xAB\x94\xA2\xD4\xC8"
    "\x65\x5F\xE5\xE9\x3E\x05\x93\x7D\xA3\x74\x97\x9C\x47\xDF\x54\x4F"
    "\x91\xEE\x7A\x1E\xEB\x21\x34\x8C\x6E\x29\x8C\x8E\x2C\x54\x95\x5C"
    "\xF8\xFD\xAE\x24\x76\x04\x76\x81\xAD\xC5\x10\x00\xB9\xFF\xCB\xED"
    "\xE5\x0C\x06\xD1\xB9\xC4\x79\x58\x65\xC3\x92\x81\x4C\x41\x1C\x4E"
    "\x5E\x47\x9F\x06\x04\x1E\x1C\x1D\xEE\x69\x97\x51\x02\x03\x01\x00"
    "\x01\x02\x82\x01\x01\x00\x89\x97\xFC\x94\xBB\x99\xC0\xF6\xF9\xF4"
    "\x42\x4B\x66\x56\x02\x54\xC7\xE4\x5A\xF0\x39\xAA\x67\x59\x76\x28"
    "\xFD\x05\x62\x5D\xAB\x03\x53\x1E\x86\x0C\x59\x2B\x02\x2C\xE0\x9A"
    "\xFB\x44\x55\xAA\xA0\x04\x83\x5B\x98\xEA\xED\xBD\xDC\x30\xB0\x4A"
    "\xF9\x99\x2B\xB1\x46\xB5\xA6\xFE\x73\x04\x85\xE0\x56\x66\xE1\x4A"
    "\x49\xFE\xA9\x48\xFB\x20\xA4\x59\xBD\x51\x3B\x62\x35\xB7\x1F\x5C"
    "\xD8\x3B\x13\x2C\x4D\xD7\xA1\x80\xAD\xD6\x55\x2E\xF2\x00\xE9\x11"
    "\x44\x9D\xB0\xB9\xA0\x83\x1F\x14\x07\xF5\xF4\x46\x40\xE9\xCF\xFF"
    "\x52\x82\x8B\x03\xE4\xB2\x66\x67\x71\xB6\x26\x21\xCC\x73\xDC\xE4"
    "\x4A\xDB\x6B\x4D\x31\xE5\x73\x06\xE8\x91\x03\x1D\xD7\xDE\x63\xC3"
    "\x43\xFE\x99\xCB\x17\x3F\x91\xE1\xD3\xAD\x07\x96\x0F\x18\x23\x43"
    "\xB3\x62\xDE\xBD\xC9\x27\x04\x7E\x7D\x0F\x64\x61\xDD\x4E\xAC\x05"
    "\xF4\xBC\x3D\x69\x92\x83\x37\xED\xB7\x99\x3F\x18\x40\x1B\x9D\x02"
    "\x7D\x5D\x20\x56\x0E\xA3\x81\xD6\x2E\x87\xDE\xC7\x99\x57\x45\xB2"
    "\xE5\xAC\x4A\xC7\xA8\xB6\x66\x54\xE3\x55\xF0\x6E\x38\xE1\xEE\x05"
    "\x1B\xDC\x5D\xC7\x1F\x36\xAD\x8C\x09\xAE\xC0\xD3\xC1\x0C\x1B\x3B"
    "\xF2\x21\x68\x19\xAE\x01\x02\x81\x81\x00\xD0\x67\x41\xD9\x9D\x83"
    "\x63\xC3\xE1\xA9\x88\x1F\x97\x10\x84\x40\x00\x4F\xAC\x09\x57\x8C"
    "\xB1\x50\x5D\x88\xDD\x29\x31\xAE\x9B\x20\x54\x1A\x37\xE1\x71\x6D"
    "\x7C\x7B\x32\xE4\xEC\xA1\xFC\x54\x63\xDE\xAB\x25\x8B\x59\x46\xE0"
    "\x7C\xCE\xAD\xC3\xFB\xFA\xF3\x8B\xAA\x90\x45\x0C\x1B\xD6\xC5\xBC"
    "\xA9\x3B\x84\x5B\x45\xF6\x92\x38\xBD\x17\x9E\xCD\xE0\x3F\x94\xBB"
    "\x86\x9D\xBD\x1E\xBB\x23\x50\x3E\x25\x1D\x15\x63\x19\xF4\xE5\xC9"
    "\xA7\x05\x3F\x37\xCF\x92\x1E\xF2\xBF\xF1\x29\x20\x79\x65\x6E\xEF"
    "\x05\x83\x89\x49\x66\x6C\x5A\x9D\xE6\x61\x02\x81\x81\x00\xC3\xC7"
    "\x4E\xFA\x50\x6E\x38\x86\xDE\xD0\x53\x47\x12\x30\xD5\x04\x0C\x8A"
    "\xC2\xA8\x60\xA1\xDC\xFA\x93\x20\x78\x45\x35\xA9\x96\x43\x34\xA4"
    "\x8F\x87\x78\x58\xDB\x98\xD1\x36\x33\x16\x81\x4F\x3E\x35\xD4\xC8"
    "\x46\x9D\xA1\x68\x7C\x4E\xF7\x6A\x52\xE4\xB1\xE2\x2A\x9E\x87\xDA"
    "\xC1\x9A\xE3\x41\x25\x01\xB1\x85\x16\x6A\xE7\x4B\xF4\x7B\x30\x3E"
    "\x32\xC7\x10\x82\x75\x48\x6C\x16\x12\x51\x61\xCF\xE4\xB1\xD9\x5D"
    "\x17\xFF\xEB\xBE\x65\xDC\x70\x05\x3B\x63\x9A\xD1\x6E\xF1\xDD\xBB"
    "\xF8\x92\x4B\x71\x67\x82\x29\x6C\x57\xB3\x9A\x73\x76\xF1\x02\x81"
    "\x80\x31\x91\x9D\xD4\x08\xE7\x0B\x7F\xB7\xD8\xFF\x0B\xA4\x7E\xC5"
    "\x36\x03\xDC\xEF\x6A\x79\x6C\x79\x70\x48\x0F\x19\xAB\x86\xA9\xA5"
    "\x34\x17\x4C\xF5\x25\xA6\x39\x08\x76\xB5\x30\x46\x28\x71\x40\x11"
    "\x51\x11\x1C\x28\xFC\xDF\x22\xDE\x0C\xBA\xBF\xF6\xDB\x45\xBA\x5E"
    "\xA3\x5A\x08\xFB\x46\x26\x5A\x2D\x56\x7E\xB0\xC6\xFF\x52\xE0\x33"
    "\xF9\xBE\x47\xF1\xA2\xAD\xD9\xBC\xB7\x20\x18\x83\x22\x6F\x1F\x98"
    "\xEC\x45\xFE\x00\x5A\x83\x9D\x67\x20\x94\x5C\xCD\xFE\x4F\x66\x25"
    "\xC9\x52\xA2\xEA\xBC\xF9\x99\xD8\x91\xE4\xC1\x94\x9F\x09\x1E\xAD"
    "\x81\x02\x81\x80\x7F\xE2\x1C\x03\xC4\x30\x0B\x3A\x86\x26\xFC\x8E"
    "\xEB\x21\xFC\xB3\x15\x62\x3A\x7E\xF4\x08\x27\x29\x82\x9B\x6E\x14"
    "\x7F\x56\x14\x72\x37\xDB\xDA\x69\x7A\x42\x48\xC7\x4C\xB9\xA3\xAB"
    "\x6A\xB2\x11\x87\xE6\x43\x20\x65\x6C\xFE\xAC\x5C\x84\x9E\xEE\x20"
    "\xB6\xD5\x6E\x53\x79\x98\x7A\x68\xAB\x53\x6D\x51\xEA\xDC\x6D\x65"
    "\x4D\x4A\xBF\x1B\x0C\xCB\x44\x2D\xE5\xE9\xE1\xA4\x79\xFD\xFC\xDF"
    "\x2E\x0E\x37\x6B\xB8\xF9\x67\x68\xE3\x5B\xCE\x7B\xAC\xAC\xAE\x3B"
    "\x84\xF0\x93\x10\xE8\x6F\x15\x92\xB2\x37\x14\x8E\xE0\x72\x05\xE3"
    "\xAA\xDB\x0B\x71\x02\x81\x80\x41\x8D\x1A\xE6\xE2\x04\xF9\x7D\x60"
    "\xC4\x1E\x10\x03\x44\x25\xD5\x7B\x5D\xF1\xAC\xB0\x6A\xD3\x42\xE1"
    "\x9A\xC2\xB8\x26\xB8\xB2\xA9\x32\x9C\x26\x3C\x6B\x87\x62\x1E\x33"
    "\xE5\xA2\x37\x1A\xD9\x29\x8A\x0B\xF2\x4E\x02\x42\x81\x37\x21\x8A"
    "\x75\x12\xD7\x54\x45\xF3\x30\xDB\x3B\xC7\x0F\x0B\xD1\x4B\x00\xED"
    "\xB0\x4B\xD4\x6D\xDB\xE4\x1D\xC9\x2B\xB9\xD6\x61\x40\x74\x4A\x8D"
    "\x50\x60\xCB\x99\xD4\x34\xEA\x8F\xB5\xD2\xFF\xCC\xD3\x5C\x3B\x4A"
    "\x33\xA9\x1E\x88\x9F\x92\x69\x45\x3A\xF8\x4D\x53\x4C\x78\x95\x13"
    "\x51\x19\xB3\x24\x15\x9E\x14";
const unsigned int rsa_key_len = 1191;

void hexdump(const void *buffer, word32 len) {
  word32 i;
  word32 cols = 16;

  printf("\"");
  for (i = 0; i < len + ((len % cols) ? (cols - len % cols) : 0); i++) {
    /* print hex data */
    if (i < len) { printf("\\x%02X", ((byte *) buffer)[i] & 0xFF); }

    if (i % cols == (cols - 1)) { printf("\"\n\""); }
  }
}

TEST(WolfSSLTest, TestRSAKeyGen) {
  int ret;
  RsaKey rsaKey;
  WC_RNG rng;
  byte *rsaKeyBuf = nullptr;
  word32 rsaKeyLen;

  ret = wc_InitRng(&rng);
  ASSERT_EQ(ret, 0);

  ret = wc_InitRsaKey(&rsaKey, nullptr);
  ASSERT_EQ(ret, 0);

  ret = wc_MakeRsaKey(&rsaKey, 2048, 65537, &rng);
  ASSERT_EQ(ret, 0);

  rsaKeyLen = 2048;
  rsaKeyBuf = static_cast<byte *>(malloc(rsaKeyLen));
  ASSERT_NE(rsaKeyBuf, nullptr);

  ret = wc_RsaKeyToDer(&rsaKey, rsaKeyBuf, rsaKeyLen);
  ASSERT_GT(ret, 0);
  rsaKeyLen = ret;
  std::cout << rsaKeyLen << std::endl;
  hexdump(rsaKeyBuf, rsaKeyLen);
}

const unsigned char rsa_msg[] =
    "\x49\x41\xbe\x0a\x0c\xc9\xf6\x35\x51\xe4\x27\x56\x13\x71\x4b\xd0"
    "\x36\x92\x84\x89\x1b\xf8\x56\x4a\x72\x61\x14\x69\x4f\x5e\x98\xa5"
    "\x80\x5a\x37\x51\x1f\xd8\xf5\xb5\x63\xfc\xf4\xb1\xbb\x4d\x33\xa3"
    "\x1e\xb9\x75\x8b\x9c\xda\x7e\x6d\x3a\x77\x85\xf7\xfc\x4e\xe7\x64"
    "\x43\x10\x19\xa0\x59\xae\xe0\xad\x4b\xd3\xc4\x45\xf7\xb1\xc2\xc1"
    "\x65\x01\x41\x39\x5b\x45\x47\xed\x2b\x51\xed\xe3\xd0\x09\x10\xd2"
    "\x39\x6c\x4a\x3f\xe5\xd2\x20\xe6\xb0\x71\x7d\x5b\xed\x26\x60\xf1"
    "\xb4\x73\xd1\xdb\x7d\xc4\x19\x91\xee\xf6\x32\x76\xf2\x19\x7d\xb7";
const unsigned int rsa_msg_size = 128;
/*
 * - The first 19 bytes of `rsa_digest` is just the BER encoding header, as
 *   wolfSSL will not insert such a header for the hash
 * - The last 32 bytes of `rsa_digest` is the SHA256 hash of `rsa_msg`
 *
 * Ref:
 * - https://datatracker.ietf.org/doc/html/rfc8017#section-9.2
 */
const unsigned char rsa_digest[] =
    "\x30\x31\x30\x0d\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x01\x05\x00\x04"
    "\x20"
    "\x3e\xc8\xa1\x26\x20\x54\x44\x52\x48\x0d\xe5\x66\xf3\xb3\xf5\x04"
    "\xbe\x10\xa8\x48\x94\x22\x2d\xdd\xba\x7a\xb4\x76\x8d\x79\x98\x89";
const unsigned int rsa_digest_size = 32 + 19;
/*
 * `rsa_sig` is generated by kernel cipher `pkcs1pad(rsa,sha256)`
 */
const unsigned char rsa_sig[] =
    "\x5e\x41\x1d\x0f\x3d\x4e\x6d\x43\xd4\xd7\x0b\x66\x2f\x22\xaf\x17"
    "\x10\x3d\x6d\x24\x45\xd7\xfa\x94\x9b\x53\x2d\x69\x9d\x2b\x38\x7a"
    "\x07\xf2\x1a\x64\x67\x27\xfe\x46\xc7\xf8\x06\xa5\xf6\x2b\x39\xfe"
    "\xd1\xb3\xfe\x83\xa7\x75\xeb\xc1\x94\xfd\x37\xbf\x8f\x1b\x1f\x32"
    "\x06\x91\x41\x8a\x96\x51\x48\x1a\x77\x1b\xb3\x3e\x25\x5c\xd5\x9b"
    "\x93\x6f\x9f\x04\xe9\x0c\x03\x7b\xd7\x8e\x63\xf1\xff\x02\xa5\xf6"
    "\xa4\x29\x24\x3d\xf9\x43\x53\xf8\xb8\x11\x8c\x84\xd0\x02\xd5\x4e"
    "\xa8\x83\x55\x3c\x40\xb4\x2c\x4e\x39\xfb\x7c\x0f\x02\x1a\xba\xce"
    "\x43\xd5\x0d\xfb\xd0\x98\xc4\x28\x84\x82\x0a\xb6\xf5\xe2\xc4\x45"
    "\x28\x33\x29\xb6\x27\x9b\x86\x63\x47\x20\xa9\xc1\x67\x8c\x3b\x5c"
    "\x6b\xeb\xd8\x5b\x05\xa2\x43\x0d\xfc\xbc\xfc\x02\x4f\xf5\xcf\xcc"
    "\xfc\x9d\xea\x3a\x6b\x05\xf8\xad\xd1\x22\x9a\xa1\xc9\xc3\xc4\x13"
    "\xf4\x89\x46\x68\x3e\xc7\x52\x54\xdb\x31\x53\xe6\xd7\xec\x67\x6c"
    "\xd3\x9f\x68\x28\x62\x07\x24\x08\x9a\xc5\xd1\x78\xf6\xc3\xe2\xff"
    "\x4c\x8d\x3d\xf6\x2d\xed\xde\xd8\x4f\x7b\xa9\x60\x64\xe0\x65\x5f"
    "\x36\xc5\xfb\x83\x7f\x8a\x16\x10\x1f\xf9\x64\xe0\x1d\x47\xd1\x9c";
const unsigned int rsa_sig_size = 256;

TEST(WolfSSLTest, TestRSASignature) {
  int ret;
  RsaKey rsaKey;
  WC_RNG rng;
  word32 idx = 0;
  word32 sigLen;
  byte sigBuf[256];

  ret = wc_InitRng(&rng);
  ASSERT_EQ(ret, 0);

  ret = wc_InitRsaKey(&rsaKey, nullptr);
  ASSERT_EQ(ret, 0);

  ret = wc_RsaPrivateKeyDecode(rsa_key, &idx, &rsaKey, rsa_key_len);
  ASSERT_EQ(ret, 0);

  sigLen =
      wc_SignatureGetSize(WC_SIGNATURE_TYPE_RSA_W_ENC, &rsaKey, sizeof(rsaKey));
  ASSERT_EQ(sigLen, rsa_sig_size);

  ret = wc_SignatureGenerateHash(
      WC_HASH_TYPE_SHA256, WC_SIGNATURE_TYPE_RSA_W_ENC, rsa_digest,
      rsa_digest_size, sigBuf, &sigLen, &rsaKey, sizeof(rsaKey), &rng);
  ASSERT_EQ(ret, 0);

  ASSERT_EQ(memcmp(sigBuf, rsa_sig, rsa_sig_size), 0);
}
